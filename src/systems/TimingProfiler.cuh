// mostly generated by claude 3.5 sonnet

#pragma once

#include <string>
#include <unordered_map>
#include <vector>
#include <chrono>
#include <mutex>
#include <memory>
#include <deque>
#include <cuda_runtime.h>

class ProfilePoint {
public:
  struct Measurement {
    double timestamp; // Time since profiler start
    double duration;  // in milliseconds
  };

  ProfilePoint(const std::string &name,
               std::chrono::high_resolution_clock::time_point profilerStartTime);
  ~ProfilePoint();

  void startMeasurement();
  void endMeasurement();
  void enable() {
    enabled = true;
  }
  void disable() {
    enabled = false;
  }
  bool isEnabled() const {
    return enabled;
  }

  // Stats getters
  double getLastDuration() const {
    return !measurements.empty() ? measurements.back().duration : 0.0;
  }
  double getAverageDuration() const;
  double getMinDuration() const;
  double getMaxDuration() const;
  size_t getSampleCount() const {
    return measurements.size();
  }

  // Get measurements within the last N seconds
  std::vector<Measurement> getRecentMeasurements(double seconds) const;

private:
  std::string name;
  bool enabled{true};
  bool active{false};

  // CPU timing
  std::chrono::high_resolution_clock::time_point cpuStartTime;
  std::chrono::high_resolution_clock::time_point profilerStartTime;

  // GPU timing
  cudaEvent_t startEvent{};
  cudaEvent_t stopEvent{};

  std::deque<Measurement> measurements;
  mutable std::mutex mutex;

  static constexpr size_t MAX_MEASUREMENTS = 1000;
  void trimMeasurements();
};

class TimingProfiler {
public:
  static TimingProfiler &getInstance() {
    static TimingProfiler instance;
    return instance;
  }

  // RAII measurement helper
  class ScopedMeasurement {
  public:
    ScopedMeasurement(const std::string &name, TimingProfiler &profiler)
        : name(name), profiler(profiler) {
      profiler.startMeasurement(name);
    }

    ~ScopedMeasurement() {
      profiler.endMeasurement(name);
    }

  private:
    std::string name;
    TimingProfiler &profiler;
  };

  // Main API
  void startMeasurement(const std::string &name);
  void endMeasurement(const std::string &name);
  ScopedMeasurement scopedMeasure(const std::string &name) {
    return ScopedMeasurement(name, *this);
  }

  // Profile point management
  void enablePoint(const std::string &name);
  void disablePoint(const std::string &name);
  bool isPointEnabled(const std::string &name) const;

  // Data access
  std::shared_ptr<ProfilePoint> getPoint(const std::string &name);
  std::vector<std::string> getProfilePointNames() const;

  // Get profiler start time for relative timestamps
  std::chrono::high_resolution_clock::time_point getStartTime() const {
    return startTime;
  }

  // Reset all measurements
  void reset();

private:
  TimingProfiler();
  ~TimingProfiler() = default;
  TimingProfiler(const TimingProfiler &) = delete;
  TimingProfiler &operator=(const TimingProfiler &) = delete;

  mutable std::mutex mutex;
  std::unordered_map<std::string, std::shared_ptr<ProfilePoint>> points;
  std::chrono::high_resolution_clock::time_point startTime;
};
