// mostly generated by claude 3.5 sonnet

#include "TimingProfiler.cuh"
#include <algorithm>
#include <limits>

ProfilePoint::ProfilePoint(const std::string &name,
                           std::chrono::high_resolution_clock::time_point profilerStartTime)
    : name(name), profilerStartTime(profilerStartTime) {
  cudaEventCreate(&startEvent);
  cudaEventCreate(&stopEvent);
}

ProfilePoint::~ProfilePoint() {
  cudaEventDestroy(startEvent);
  cudaEventDestroy(stopEvent);
}

void ProfilePoint::startMeasurement() {
  std::lock_guard<std::mutex> lock(mutex);
  if (!enabled || active)
    return;

  cpuStartTime = std::chrono::high_resolution_clock::now();
  cudaEventRecord(startEvent); // Records in default stream
  active = true;
}

void ProfilePoint::endMeasurement() {
  std::lock_guard<std::mutex> lock(mutex);
  if (!enabled || !active)
    return;

  cudaEventRecord(stopEvent); // Records in default stream

  // Get CPU time first
  auto cpuEndTime = std::chrono::high_resolution_clock::now();
  auto cpuDuration = std::chrono::duration<double, std::milli>(cpuEndTime - cpuStartTime).count();

  // Get GPU time
  cudaEventSynchronize(stopEvent); // Wait for GPU work to complete
  float gpuMilliseconds = 0.0f;
  cudaEventElapsedTime(&gpuMilliseconds, startEvent, stopEvent);

  // Use the longer of CPU or GPU time as the actual duration
  auto duration = std::max(cpuDuration, static_cast<double>(gpuMilliseconds));

  auto timestamp = std::chrono::duration<double>(cpuEndTime - profilerStartTime).count();

  measurements.push_back({timestamp, duration});
  trimMeasurements();
  active = false;
}

void ProfilePoint::trimMeasurements() {
  while (measurements.size() > MAX_MEASUREMENTS) {
    measurements.pop_front();
  }
}

double ProfilePoint::getAverageDuration() const {
  std::lock_guard<std::mutex> lock(mutex);
  if (measurements.empty())
    return 0.0;

  double sum = 0.0;
  for (const auto &m : measurements) {
    sum += m.duration;
  }
  return sum / measurements.size();
}

double ProfilePoint::getMinDuration() const {
  std::lock_guard<std::mutex> lock(mutex);
  if (measurements.empty())
    return 0.0;

  return std::min_element(
             measurements.begin(), measurements.end(),
             [](const Measurement &a, const Measurement &b) { return a.duration < b.duration; })
      ->duration;
}

double ProfilePoint::getMaxDuration() const {
  std::lock_guard<std::mutex> lock(mutex);
  if (measurements.empty())
    return 0.0;

  return std::max_element(
             measurements.begin(), measurements.end(),
             [](const Measurement &a, const Measurement &b) { return a.duration < b.duration; })
      ->duration;
}

std::vector<ProfilePoint::Measurement> ProfilePoint::getRecentMeasurements(double seconds) const {
  std::lock_guard<std::mutex> lock(mutex);
  if (measurements.empty())
    return {};

  double currentTime = measurements.back().timestamp;
  double cutoffTime = currentTime - seconds;

  auto it =
      std::find_if(measurements.rbegin(), measurements.rend(), [cutoffTime](const Measurement &m) {
        return m.timestamp < cutoffTime;
      }).base();

  return std::vector<Measurement>(it, measurements.end());
}

// TimingProfiler implementation
TimingProfiler::TimingProfiler() : startTime(std::chrono::high_resolution_clock::now()) {}

void TimingProfiler::startMeasurement(const std::string &name) {
  std::lock_guard<std::mutex> lock(mutex);
  auto &point = points[name];
  if (!point) {
    point = std::make_shared<ProfilePoint>(name, startTime);
  }
  point->startMeasurement();
}

void TimingProfiler::endMeasurement(const std::string &name) {
  std::lock_guard<std::mutex> lock(mutex);
  if (auto it = points.find(name); it != points.end()) {
    it->second->endMeasurement();
  }
}

void TimingProfiler::enablePoint(const std::string &name) {
  std::lock_guard<std::mutex> lock(mutex);
  if (auto it = points.find(name); it != points.end()) {
    it->second->enable();
  }
}

void TimingProfiler::disablePoint(const std::string &name) {
  std::lock_guard<std::mutex> lock(mutex);
  if (auto it = points.find(name); it != points.end()) {
    it->second->disable();
  }
}

bool TimingProfiler::isPointEnabled(const std::string &name) const {
  std::lock_guard<std::mutex> lock(mutex);
  if (auto it = points.find(name); it != points.end()) {
    return it->second->isEnabled();
  }
  return false;
}

std::shared_ptr<ProfilePoint> TimingProfiler::getPoint(const std::string &name) {
  std::lock_guard<std::mutex> lock(mutex);
  if (auto it = points.find(name); it != points.end()) {
    return it->second;
  }
  return nullptr;
}

std::vector<std::string> TimingProfiler::getProfilePointNames() const {
  std::lock_guard<std::mutex> lock(mutex);
  std::vector<std::string> names;
  names.reserve(points.size());
  for (const auto &[name, _] : points) {
    names.push_back(name);
  }
  return names;
}

void TimingProfiler::reset() {
  std::lock_guard<std::mutex> lock(mutex);
  points.clear();
  startTime = std::chrono::high_resolution_clock::now();
}
