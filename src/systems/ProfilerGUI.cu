// mostly generated by claude 3.5 sonnet

#include "ProfilerGUI.cuh"
#include <vector>
#include <algorithm>
#include <numeric>

ProfilerGui::ProfilerGui() : timeRange(5.0f), windowFlags(ImGuiWindowFlags_None) {}

void ProfilerGui::render() {
  if (!ImGui::Begin("Timing Profiler", nullptr, windowFlags)) {
    ImGui::End();
    return;
  }

  auto &profiler = TimingProfiler::getInstance();
  const auto names = profiler.getProfilePointNames();
  if (names.empty()) {
    ImGui::End();
    return;
  }

  // Calculate total average time
  double total_avg = 0.0;
  for (const auto &name : names) {
    if (auto point = profiler.getPoint(name)) {
      total_avg += point->getAverageDuration();
    }
  }

  // Display total at the top
  ImGui::Text("Total Average: %.2f ms", total_avg);
  ImGui::Separator();

  // Simple bar graph showing average times
  const float BAR_HEIGHT = 20.0f;
  const float TEXT_WIDTH = 120.0f; // Width reserved for labels
  const float PADDING = 2.0f;
  const float MAX_BAR_WIDTH = ImGui::GetContentRegionAvail().x - TEXT_WIDTH;

  // Find the maximum average time to scale the bars
  float max_time = 0.0f;
  for (const auto &name : names) {
    if (auto point = profiler.getPoint(name)) {
      max_time = std::max(max_time, (float)point->getAverageDuration());
    }
  }

  // Ensure we have a reasonable minimum scale
  max_time = std::max(max_time, 1.0f);

  for (const auto &name : names) {
    auto point = profiler.getPoint(name);
    if (!point)
      continue;

    // Checkbox and label
    bool enabled = point->isEnabled();
    if (ImGui::Checkbox(("##" + name).c_str(), &enabled)) {
      if (enabled)
        profiler.enablePoint(name);
      else
        profiler.disablePoint(name);
    }
    ImGui::SameLine();

    // Get the average time and format the label
    float avg_time = point->getAverageDuration();
    std::string label = name + ": " + std::to_string(avg_time).substr(0, 5) + "ms";

    // Calculate bar width
    float bar_width = (avg_time / max_time) * MAX_BAR_WIDTH;

    // Reserve space for the bar
    ImVec2 cursor = ImGui::GetCursorPos();
    ImGui::Dummy(ImVec2(MAX_BAR_WIDTH, BAR_HEIGHT));

    // Draw the bar
    ImDrawList *draw_list = ImGui::GetWindowDrawList();
    ImVec2 win_pos = ImGui::GetWindowPos();
    ImVec2 bar_start(win_pos.x + cursor.x + TEXT_WIDTH, win_pos.y + cursor.y + PADDING);
    ImVec2 bar_end(bar_start.x + bar_width, bar_start.y + BAR_HEIGHT - 2 * PADDING);

    // Draw the bar with color based on duration
    ImU32 color = getColorForDuration(avg_time);
    draw_list->AddRectFilled(bar_start, bar_end, color);

    // Draw the label over the reserved space
    ImVec2 text_pos(win_pos.x + cursor.x, win_pos.y + cursor.y);
    draw_list->AddText(text_pos, IM_COL32(255, 255, 255, 255), label.c_str());

    ImGui::SetCursorPosY(cursor.y + BAR_HEIGHT);
  }

  ImGui::End();
}

ImU32 ProfilerGui::getColorForDuration(float duration) const {
  float t;
  ImU32 color_a, color_b;

  if (duration <= GOOD_THRESHOLD) {
    return IM_COL32(50, 255, 50, 255); // Green
  } else if (duration <= WARN_THRESHOLD) {
    t = (duration - GOOD_THRESHOLD) / (WARN_THRESHOLD - GOOD_THRESHOLD);
    color_a = IM_COL32(50, 255, 50, 255);  // Green
    color_b = IM_COL32(255, 255, 50, 255); // Yellow
  } else if (duration <= BAD_THRESHOLD) {
    t = (duration - WARN_THRESHOLD) / (BAD_THRESHOLD - WARN_THRESHOLD);
    color_a = IM_COL32(255, 255, 50, 255); // Yellow
    color_b = IM_COL32(255, 50, 50, 255);  // Red
  } else {
    return IM_COL32(255, 50, 50, 255); // Red
  }

  // Linear interpolation between colors
  ImVec4 col_a = ImGui::ColorConvertU32ToFloat4(color_a);
  ImVec4 col_b = ImGui::ColorConvertU32ToFloat4(color_b);
  ImVec4 col = ImVec4(col_a.x + (col_b.x - col_a.x) * t, col_a.y + (col_b.y - col_a.y) * t,
                      col_a.z + (col_b.z - col_a.z) * t, 1.0f);

  return ImGui::ColorConvertFloat4ToU32(col);
}
